- gcc_o:	max. leistung: ca. 360
		anfang: alles ähnlich, 100 kaum aussagekräftig, ab 1e6: stride > 1 deutlich schlechter als stride = 1, größerer stride -> schlechterer wert, stimmt für 16 bis 64 überein
- gcc_o0:	= _o
- gcc_o3:	rechenleistung bis faktor 3 besser (auf max. 1300), ab n=1e4: wieder deutlicher einfluss von stride!=1, erniedrigung 
		um ca. 200, bis min. 400, ab n=1e6: wie _o0
		erste stufe: n=1e3 entspricht 7.8kByte, cache size: 6144kB -> ab n=1e6 passt der vektor nicht mehr in den cache, clflush size: 64, cache_alignment: 64
		stride 1 -> viele sinnvolle daten in cache -> ideales nachladen








vektorlänge n, double-größe: 8byte->64bit
for entspricht if -> pipeline läuft leer, cache+register evtl neu laden

es müssen zwei vektoren reinpassen, man kann den genauen punkt hier nicht sehen
annahme : compiler vektorisieren eigenständig (bei o3), was hier gut möglich ist (keine abhängigkeiten)